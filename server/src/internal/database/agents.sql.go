// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: agents.sql

package database

import (
	"context"
	"database/sql"
	"time"
)

const createSearchAgent = `-- name: CreateSearchAgent :one
INSERT INTO agents (name, user_id) 
VALUES (
    $1,
    $2
) RETURNING id, name, user_id, last_fetched_at, created_at, updated_at
`

type CreateSearchAgentParams struct {
	Name   string
	UserID int32
}

func (q *Queries) CreateSearchAgent(ctx context.Context, arg CreateSearchAgentParams) (Agent, error) {
	row := q.db.QueryRowContext(ctx, createSearchAgent, arg.Name, arg.UserID)
	var i Agent
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.UserID,
		&i.LastFetchedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getAgentByName = `-- name: GetAgentByName :one
SELECT id, name, user_id, last_fetched_at, created_at, updated_at from agents
WHERE name = $1
`

func (q *Queries) GetAgentByName(ctx context.Context, name string) (Agent, error) {
	row := q.db.QueryRowContext(ctx, getAgentByName, name)
	var i Agent
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.UserID,
		&i.LastFetchedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getNextAgentToUpdate = `-- name: GetNextAgentToUpdate :one
SELECT id, name, user_id, last_fetched_at, created_at, updated_at from agents
WHERE last_fetched_at + interval '3 minutes' < CURRENT_TIMESTAMP
OR last_fetched_at IS NULL
ORDER BY last_fetched_at ASC NULLS FIRST
`

func (q *Queries) GetNextAgentToUpdate(ctx context.Context) (Agent, error) {
	row := q.db.QueryRowContext(ctx, getNextAgentToUpdate)
	var i Agent
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.UserID,
		&i.LastFetchedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listAgents = `-- name: ListAgents :many
SELECT id, name, user_id, last_fetched_at, created_at, updated_at FROM agents
`

func (q *Queries) ListAgents(ctx context.Context) ([]Agent, error) {
	rows, err := q.db.QueryContext(ctx, listAgents)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Agent
	for rows.Next() {
		var i Agent
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.UserID,
			&i.LastFetchedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAgentsWithImages = `-- name: ListAgentsWithImages :many
SELECT a.id, a.name, a.user_id, a.last_fetched_at, a.created_at, a.updated_at, 
       COALESCE((SELECT i.url 
        FROM images i 
        JOIN results r ON i.ad_id = r.ad_id 
        JOIN agent_params ap ON r.params_id = ap.params_id 
        WHERE ap.agent_id = a.id AND i.label = 'thumbnail' AND i.image_number = 0
        ORDER BY i.created_at DESC
        LIMIT 1), '')::TEXT AS thumbnail
FROM agents a
`

type ListAgentsWithImagesRow struct {
	ID            int32
	Name          string
	UserID        int32
	LastFetchedAt sql.NullTime
	CreatedAt     time.Time
	UpdatedAt     time.Time
	Thumbnail     string
}

func (q *Queries) ListAgentsWithImages(ctx context.Context) ([]ListAgentsWithImagesRow, error) {
	rows, err := q.db.QueryContext(ctx, listAgentsWithImages)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAgentsWithImagesRow
	for rows.Next() {
		var i ListAgentsWithImagesRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.UserID,
			&i.LastFetchedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Thumbnail,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markAgentUpdated = `-- name: MarkAgentUpdated :exec
UPDATE agents 
SET updated_at=CURRENT_TIMESTAMP, last_fetched_at=CURRENT_TIMESTAMP 
WHERE id=$1
`

func (q *Queries) MarkAgentUpdated(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, markAgentUpdated, id)
	return err
}
